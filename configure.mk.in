# Copyright (c) 2009, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

######################################################################
# See  mk-configure(7) for documentation
#

# user defined variables
MKC_SHOW_CACHED?=0       # set it to `1' to show "...(cached)..." lines
MKC_DELETE_TMPFILES?=0   # set it to `1' to delete temporary files
MKC_CACHEDIR?=${.OBJDIR} # directory for cache and intermediate files
MKC_COMMON_HEADERS?=     # list of headers always #included
MKC_NOCACHE?=            # 1 or yes for disabling cache
MKC_CUSTOM_DIR?=${.CURDIR} # directory with custom tests.c

DISTCLEANFILES+=	${MKC_CACHEDIR}/_mkc_*

.if !make(clean) && !make(cleandir) && !make(distclean) # .endif is in the end of file

#
.ifndef OPSYS
OPSYS!=	uname -s
.endif

TARGET_OPSYS?=	${OPSYS}
.if defined(MKC_COMMON_DEFINES.${TARGET_OPSYS})
CPPFLAGS+=		${MKC_COMMON_DEFINES.${TARGET_OPSYS}}
.endif
.if defined(MKC_COMMON_DEFINES)
CPPFLAGS+=		${MKC_COMMON_DEFINES}
.endif

#
_MKC_CPPFLAGS:=		${CPPFLAGS}
_MKC_CFLAGS:=		${CFLAGS}
_MKC_CXXFLAGS:=		${CXXFLAGS}
_MKC_FFLAGS:=		${FFLAGS}
_MKC_LDFLAGS:=		${LDFLAGS}
_MKC_LDADD:=		${LDADD}

mkc.environ=CC='${CC}' YACC='${YACC}' CXX='${CXX}' FC='${FC}' CPPFLAGS='${_MKC_CPPFLAGS}' CFLAGS='${_MKC_CFLAGS}' CXXFLAGS='${_MKC_CXXFLAGS}' FFLAGS='${_MKC_FFLAGS}' LDFLAGS='${_MKC_LDFLAGS}' LDADD='${_MKC_LDADD}' MKC_CACHEDIR='${MKC_CACHEDIR}' MKC_COMMON_HEADERS='${MKC_COMMON_HEADERS}' MKC_DELETE_TMPFILES='${MKC_DELETE_TMPFILES}' MKC_SHOW_CACHED='${MKC_SHOW_CACHED}' MKC_NOCACHE='${MKC_NOCACHE}' MKC_VERBOSE=1

#
MKC_SOURCE_FUNCLIBS   ?=
_MKC_SOURCE_FUNCS=	${MKC_SOURCE_FUNCLIBS:C/:.*//}
#MKC_CHECK_HEADERS     ?=
#MKC_CHECK_SIZEOF      ?=
#MKC_CHECK_DEFINES     ?=
#MKC_CHECK_VARS        ?=

# checking for headers
.for h in ${MKC_CHECK_HEADERS} ${MKC_REQUIRE_HEADERS}
.if !defined(HAVE_HEADER.${h:S|.|_|g:S|/|_|g})
HAVE_HEADER.${h:S|.|_|g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_header ${h}
.endif
.if ${HAVE_HEADER.${h:S|.|_|g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_HEADER_${h:tu:S|.|_|g:S|/|_|g}=${HAVE_HEADER.${h:S|.|_|g:S|/|_|g}}
.elif !empty(MKC_REQUIRE_HEADERS:U:M${h})
MKC_ERR_MSG+=		"ERROR: cannot find header ${h}"
.endif
.endfor

.undef MKC_CHECK_HEADERS
.undef MKC_REQUIRE_HEADERS

# checking for functions in libraries
.for f in ${MKC_CHECK_FUNCLIBS:U:S/:/;/g} ${MKC_SOURCE_FUNCLIBS:U:S/:/;/g} ${MKC_REQUIRE_FUNCLIBS:U:S/:/;/g}
.if !defined(HAVE_FUNCLIB.${f:S/;/./g})
HAVE_FUNCLIB.${f:S/;/./g}!=	env ${mkc.environ} mkc_check_funclib ${f:S/;/ /g}
.endif
.if !defined(HAVE_FUNCLIB.${f:C/;.*//})
HAVE_FUNCLIB.${f:C/;.*//}!=	env ${mkc.environ} mkc_check_funclib ${f:C/;.*//}
.endif
.if ${HAVE_FUNCLIB.${f:C/;.*//}} != ${HAVE_FUNCLIB.${f:S/;/./g}}
.if empty(MKC_NOAUTO_FUNCLIBS:U:S/:/./g:M${f:S/;/./g}) && empty(MKC_NOAUTO_FUNCLIBS:U:M1) && ${HAVE_FUNCLIB.${f:S/;/./g}} && !${HAVE_FUNCLIB.${f:C/;.*//}}
MKC_LDADD+=-l${f:C/^.*;//}
.endif
.endif
.if !${HAVE_FUNCLIB.${f:S/;/./g}} && !${HAVE_FUNCLIB.${f:C/;.*//}} && !empty(_MKC_SOURCE_FUNCS:M${f:C/;.*//})
MKC_SRCS+=${f:C/;.*//}.c
.endif
.endfor # f

.for f in ${MKC_REQUIRE_FUNCLIBS:U:S/:/;/g}
.if !${HAVE_FUNCLIB.${f:S/;/./g}} && !${HAVE_FUNCLIB.${f:C/;.*//}}
MKC_ERR_MSG+=		"ERROR: cannot find function ${f:S/;/:/g}"
.endif
.endfor # f

.undef MKC_CHECK_FUNCLIBS
.undef MKC_SOURCE_FUNCLIBS
.undef MKC_REQUIRE_FUNCLIBS

# checking for sizeof(xxx)
.for t in ${MKC_CHECK_SIZEOF:U:S/:/;/g}
.if !defined(SIZEOF.${t:S|.|_|g:S|-|_|g:S|*|P|g:S|/|_|g:S|;|.|g})
SIZEOF.${t:S|.|_|g:S|-|_|g:S|*|P|g:S|/|_|g:S|;|.|g}   !=   env ${mkc.environ} mkc_check_sizeof ${t:S/;/ /g}
.endif
.if ${SIZEOF.${t:S|.|_|g:S|-|_|g:S|*|P|g:S|/|_|g:S|;|.|g}} != failed
MKC_CFLAGS  +=  -DSIZEOF_${t:S/-/_/g:S| |_|g:S|*|P|g:S|;|_|g:S|.|_|g:tu}=${SIZEOF.${t:S|.|_|g:S|-|_|g:S|*|P|g:S|/|_|g:S|;|.|g}}
.endif
.endfor

.undef MKC_CHECK_SIZEOF

# checking for declared #define
.for d in ${MKC_CHECK_DEFINES:U:S/:/;/g} ${MKC_REQUIRE_DEFINES:U:S/:/;/g}
.if !defined(HAVE_DEFINE.${d:S/./_/g:S/;/./g:S|/|_|g})
HAVE_DEFINE.${d:S/./_/g:S/;/./g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_decl define ${d:S/;/ /g}
.endif
.if ${HAVE_DEFINE.${d:S/./_/g:S/;/./g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_DEFINE_${d:tu:S/;/_/g:S/./_/g:S|/|_|g}=1
.endif
.endfor

.for d in ${MKC_REQUIRE_DEFINES:U:S/:/;/g}
.if !${HAVE_DEFINE.${d:S/./_/g:S/;/./g:S|/|_|g}}
MKC_ERR_MSG+=		"ERROR: cannot find declaration of define ${d:S/;/:/g}"
.endif
.endfor

.undef MKC_CHECK_DEFINES
.undef MKC_REQUIRE_DEFINES

# checking for declared type
.for t in ${MKC_CHECK_TYPES:U:S/:/;/g} ${MKC_REQUIRE_TYPES:U:S/:/;/g}
.if !defined(HAVE_TYPE.${t:S/./_/g:S/;/./g:S|/|_|g})
HAVE_TYPE.${t:S/./_/g:S/;/./g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_decl type ${t:S/;/ /g}
.endif
.if ${HAVE_TYPE.${t:S/./_/g:S/;/./g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_TYPE_${t:tu:S/;/_/g:S/./_/g:S|/|_|g}=1
.endif
.endfor

.for t in ${MKC_REQUIRE_TYPES:U:S/:/;/g}
.if !${HAVE_TYPE.${t:S/./_/g:S/;/./g:S|/|_|g}}
MKC_ERR_MSG+=		"ERROR: cannot find declaration of type ${t:S/;/:/g}"
.endif
.endfor

.undef MKC_CHECK_TYPES
.undef MKC_REQUIRE_TYPES

# checking for declared variables
.for d in ${MKC_CHECK_VARS:U:S/:/;/g} ${MKC_REQUIRE_VARS:U:S/:/;/g}
.if !defined(HAVE_VAR.${d:S/./_/g:S/;/./g:S|/|_|g})
HAVE_VAR.${d:S/./_/g:S/;/./g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_decl variable ${d:S/;/ /g}
.endif
.if ${HAVE_VAR.${d:S/./_/g:S/;/./g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_VAR_${d:tu:S/;/_/g:S/./_/g:S|/|_|g}=1
.endif
.endfor

.for d in ${MKC_REQUIRE_VARS:U:S/:/;/g}
.if !${HAVE_VAR.${d:S/./_/g:S/;/./g:S|/|_|g}}
MKC_ERR_MSG+=		"ERROR: cannot find declaration of variable ${d:S/;/:/g}"
.endif
.endfor

.undef MKC_REQUIRE_VARS

# checking for struct members
.for m in ${MKC_CHECK_MEMBERS:U:S/:/;/g} ${MKC_REQUIRE_MEMBERS:U:S/:/;/g}
.if !defined(HAVE_MEMBER.${m:S/./_/g:S/;/./g:S|/|_|g:S/-/_/g})
HAVE_MEMBER.${m:S/./_/g:S/;/./g:S|/|_|g:S/-/_/g}   !=   env ${mkc.environ} mkc_check_decl member ${m:S/;/ /g}
.endif
.if ${HAVE_MEMBER.${m:S/./_/g:S/;/./g:S|/|_|g:S/-/_/g}}
MKC_CFLAGS  +=  -DHAVE_MEMBER_${m:tu:S/;/_/g:S/./_/g:S|/|_|g:S/-/_/g}=1
.endif
.endfor

.for m in ${MKC_REQUIRE_MEMBERS:U:S/:/;/g}
.if !${HAVE_MEMBER.${m:S/./_/g:S/;/./g:S|/|_|g:S/-/_/g}}
MKC_ERR_MSG+=		"ERROR: cannot find member ${m:S/;/:/g}"
.endif
.endfor

.undef MKC_CHECK_MEMBERS
.undef MKC_REQUIRE_MEMBERS

# checking for declared functions
.for n in 0 1 2 3 4 5 6 7 8 9

.for d in ${MKC_CHECK_FUNCS${n}:U:S/:/;/g} ${MKC_REQUIRE_FUNCS${n}:U:S/:/;/g}
.if !defined(HAVE_FUNC${n}.${d:S/./_/g:S/;/./g:S|/|_|g})
HAVE_FUNC${n}.${d:S/./_/g:S/;/./g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_decl func${n} ${d:S/;/ /g}
.endif
.if ${HAVE_FUNC${n}.${d:S/./_/g:S/;/./g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_FUNC${n}_${d:tu:S/;/_/g:S/./_/g:S|/|_|g}=1
.endif
.endfor # d

.for d in ${MKC_REQUIRE_FUNCS${n}:U:S/:/;/g}
.if !${HAVE_FUNC${n}.${d:S/./_/g:S/;/./g:S|/|_|g}}
MKC_ERR_MSG+=		"ERROR: cannot find declaration of function ${d:S/;/:/g}"
.endif
.endfor # d

.undef MKC_CHECK_FUNCS${n}
.undef MKC_REQUIRE_FUNCS${n}

.endfor # n

# custom checks
.for c in ${MKC_CHECK_CUSTOM} ${MKC_REQUIRE_CUSTOM}
.if !defined(HAVE_CUSTOM.${c})
.if !defined(MKC_CUSTOM_FN.${c})
MKC_CUSTOM_FN.${c}=${c}.c
.endif
HAVE_CUSTOM.${c}   !=   env ${mkc.environ} mkc_check_custom \
	${MKC_CUSTOM_FN.${c}:H:S|^.$|${MKC_CUSTOM_DIR}|}/${MKC_CUSTOM_FN.${c}:T}
.endif
.if ${HAVE_CUSTOM.${c}}
MKC_CFLAGS  +=  -DHAVE_CUSTOM_${c:tu}=${HAVE_CUSTOM.${c}}
.endif
.endfor

.for c in ${MKC_REQUIRE_CUSTOM}
.if !${HAVE_CUSTOM.${c}}
MKC_ERR_MSG+=		"ERROR: custom test ${c} failed"
.endif
.endfor

.undef MKC_CHECK_CUSTOM
.undef MKC_REQUIRE_CUSTOM

# checking for declared #define
.for p in ${MKC_CHECK_PROGS} ${MKC_REQUIRE_PROGS}
.if !defined(PROG.${p})
PROG.${p}   !=   	env ${mkc.environ} mkc_check_prog '${p}'
.endif # !defined(PROG.${p})
.if !empty(PROG.${p})
HAVE_PROG.${p}=		1
.else
HAVE_PROG.${p}=		0
.endif
.endfor # p

.for p in ${MKC_REQUIRE_PROGS}
.if !${HAVE_PROG.${p}}
MKC_ERR_MSG+=		"ERROR: cannot find program ${p}"
.endif
.endfor # p

.undef MKC_CHECK_PROGS
.undef MKC_REQUIRE_PROGS

# final assignment
.if !${MKC_NOAUTO:U0}
.for i in ${MKC_CFLAGS}
CFLAGS+=	${i}
.endfor
.for i in ${MKC_LDADD}
LDADD+=		${i}
.endfor
.for i in ${MKC_SRCS}
SRCS+=		${i}
.endfor

.undef MKC_SRCS
.undef MKC_LDADD
.undef MKC_CFLAGS

.endif # .if MKC_AUTO

.endif # !make(clean) && !make(cleandir) && !make(distclean)
