# Copyright (c) 2009, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

######################################################################
# MKC_NOAUTO_FUNCLIBS
#       See MKC_CHECK_FUNCLIBS
#
# MKC_NOAUTO
#       See MKC_CHECK_{HEADERS,FUNCLIBS,FUNCS,VARS,DEFINES,SIZEOF}.
#
# MKC_COMMON_HEADERS
#       List of header files always #include'd to the test .c files
#       in MKC_CHECK_{DEFINES,VARS,FUNCS<N>,SIZEOF} tests.
#       The default value is an empty list.
#   Ex: MKC_COMMON_HEADERS += unistd.h stdlib stdio.h string.h
#       MKC_CHECK_SIZEOF += offs_t size_t ssize_t
#
# MKC_CACHEDIR
#       Directory where intermediate and cache files are created.
#       It defaults to ${.OBJDIR}.
#       Setting this variable to something common for huge amount of
#       projects can save lots of time/energy wasted on unnecessary
#       rechecking. Idea: to use hash from options passed to compiler
#       for calculating the cache directory
#       ( remove -Wxxx etc. + sort + uniq + crc32/md5/...).
#
# MKC_SHOW_CACHED
#        Set it to 0 when working with mk-configure-based Makefile
#        interactively. This will hide annoying messages about
#        fetching test result from the cache.
#
# MKC_DELETE_TMPFILES
#        If set to 1, temporary files are removed.
#
# MKC_SHELL
#        Shell interpreter for mkc_check_XXX scripts, defaults to /bin/sh
#
# MKC_NOCACHE
#        All results are cached unless MKC_NOCACHE variable is set
#        non-empty value

######################################################################
# system variables
MKC_VERSION=@@version@@

# user defined variables
MKC_SHOW_CACHED?=1       # set it to `0' to hide "...(cached)..." lines
MKC_DELETE_TMPFILES?=0   # set it to `1' to delete temporary files
MKC_CACHEDIR?=${.OBJDIR} # directory for cache and intermediate files
MKC_COMMON_HEADERS?=     # list of headers always #included
MKC_SHELL?=/bin/sh       # mainly for portability testing purposes
MKC_NOCACHE?=            # 1 or yes for disabling cache
MKC_CUSTOM_DIR?=${.CURDIR} # directory with custom tests.c

DISTCLEANFILES+=	${MKC_CACHEDIR}/_mkc_*

.if !make(clean) && !make(cleandir) && !make(distclean) # .endif is in the end of file

#
.ifndef OSNAME
OSNAME!=		uname -s
.endif
.if defined(MKC_COMMON_DEFINES.${OSNAME})
CPPFLAGS+=		${MKC_COMMON_DEFINES.${OSNAME}}
.endif
.if defined(MKC_COMMON_DEFINES)
CPPFLAGS+=		${MKC_COMMON_DEFINES}
.endif

#
_MKC_CPPFLAGS:=		${CPPFLAGS}
_MKC_CFLAGS:=		${CFLAGS}
_MKC_LDFLAGS:=		${LDFLAGS}
_MKC_LDADD:=		${LDADD}

mkc.environ=CC='${CC}' CPPFLAGS='${_MKC_CPPFLAGS}' CFLAGS='${_MKC_CFLAGS}' LDFLAGS='${_MKC_LDFLAGS}' LDADD='${_MKC_LDADD}' MKC_CACHEDIR='${MKC_CACHEDIR}' MKC_COMMON_HEADERS='${MKC_COMMON_HEADERS}' MKC_DELETE_TMPFILES='${MKC_DELETE_TMPFILES}' MKC_SHOW_CACHED='${MKC_SHOW_CACHED}' MKC_NOCACHE='${MKC_NOCACHE}' MKC_VERBOSE=1 MKC_SHELL='${MKC_SHELL}'

#
MKC_SOURCE_FUNCLIBS   ?=
_MKC_SOURCE_FUNCS=	${MKC_SOURCE_FUNCLIBS:C/:.*//}
#MKC_CHECK_HEADERS     ?=
#MKC_CHECK_SIZEOF      ?=
#MKC_CHECK_DEFINES     ?=
#MKC_CHECK_VARS        ?=

# checking for headers
.for h in ${MKC_CHECK_HEADERS} ${MKC_REQUIRE_HEADERS}
.if !defined(HAVE_HEADER.${h:S|.|_|g:S|/|_|g})
HAVE_HEADER.${h:S|.|_|g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_header ${h}
.endif
.if ${HAVE_HEADER.${h:S|.|_|g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_HEADER_${h:tu:S|.|_|g:S|/|_|g}=${HAVE_HEADER.${h:S|.|_|g:S|/|_|g}}
.elif !empty(MKC_REQUIRE_HEADERS:U:M${h})
MKC_ERR_MSG+=		"ERROR: cannot find header ${h}"
.endif
.endfor

# checking for functions in libraries
.for f in ${MKC_CHECK_FUNCLIBS} ${MKC_SOURCE_FUNCLIBS} ${MKC_REQUIRE_FUNCLIBS}
.if !defined(HAVE_FUNCLIB.${f:S/:/./g})
HAVE_FUNCLIB.${f:S/:/./g}!=	env ${mkc.environ} mkc_check_funclib ${f:S/:/ /g}
.endif
.if !defined(HAVE_FUNCLIB.${f:C/:.*//})
HAVE_FUNCLIB.${f:C/:.*//}!=	env ${mkc.environ} mkc_check_funclib ${f:C/:.*//}
.endif
.if ${HAVE_FUNCLIB.${f:C/:.*//}} != ${HAVE_FUNCLIB.${f:S/:/./g}}
.if empty(MKC_NOAUTO_FUNCLIBS:U:S/:/./g:M${f:S/:/./g}) && empty(MKC_NOAUTO_FUNCLIBS:U:M1) && ${HAVE_FUNCLIB.${f:S/:/./g}} && !${HAVE_FUNCLIB.${f:C/:.*//}}
MKC_LDADD+=-l${f:C/^.*://}
.endif
.endif
.if !${HAVE_FUNCLIB.${f:S/:/./g}} && !${HAVE_FUNCLIB.${f:C/:.*//}} && !empty(_MKC_SOURCE_FUNCS:M${f:C/:.*//})
MKC_SRCS+=${f:C/:.*//}.c
.endif
.endfor # f

.for f in ${MKC_REQUIRE_FUNCLIBS}
.if !${HAVE_FUNCLIB.${f:S/:/./g}} && !${HAVE_FUNCLIB.${f:C/:.*//}}
MKC_ERR_MSG+=		"ERROR: cannot find function ${f}"
.endif
.endfor # f

# checking for sizeof(xxx)
.for t in ${MKC_CHECK_SIZEOF}
.if !defined(SIZEOF.${t:S|.|_|g:S|-|_|g:S|*|P|g:S|/|_|g:S|:|.|g})
SIZEOF.${t:S|.|_|g:S|-|_|g:S|*|P|g:S|/|_|g:S|:|.|g}   !=   env ${mkc.environ} mkc_check_sizeof ${t:S/:/ /g}
.endif
.if ${SIZEOF.${t:S|.|_|g:S|-|_|g:S|*|P|g:S|/|_|g:S|:|.|g}} != failed
MKC_CFLAGS  +=  -DSIZEOF_${t:S/-/_/g:S| |_|g:S|*|P|g:S|:|_|g:S|.|_|g:tu}=${SIZEOF.${t:S|.|_|g:S|-|_|g:S|*|P|g:S|/|_|g:S|:|.|g}}
.endif
.endfor

# checking for declared #define
.for d in ${MKC_CHECK_DEFINES} ${MKC_REQUIRE_DEFINES}
.if !defined(HAVE_DEFINE.${d:S/./_/g:S/:/./g:S|/|_|g})
HAVE_DEFINE.${d:S/./_/g:S/:/./g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_decl define ${d:S/:/ /g}
.endif
.if ${HAVE_DEFINE.${d:S/./_/g:S/:/./g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_DEFINE_${d:tu:S/:/_/g:S/./_/g:S|/|_|g}=1
.endif
.endfor

.for d in ${MKC_REQUIRE_DEFINES}
.if !${HAVE_DEFINE.${d:S/./_/g:S/:/./g:S|/|_|g}}
MKC_ERR_MSG+=		"ERROR: cannot find declaration of define ${d}"
.endif
.endfor

# checking for declared type
.for t in ${MKC_CHECK_TYPES} ${MKC_REQUIRE_TYPES}
.if !defined(HAVE_TYPE.${t:S/./_/g:S/:/./g:S|/|_|g})
HAVE_TYPE.${t:S/./_/g:S/:/./g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_decl type ${t:S/:/ /g}
.endif
.if ${HAVE_TYPE.${t:S/./_/g:S/:/./g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_TYPE_${t:tu:S/:/_/g:S/./_/g:S|/|_|g}=1
.endif
.endfor

.for t in ${MKC_REQUIRE_TYPES}
.if !${HAVE_TYPE.${t:S/./_/g:S/:/./g:S|/|_|g}}
MKC_ERR_MSG+=		"ERROR: cannot find declaration of type ${t}"
.endif
.endfor

# checking for declared variables
.for d in ${MKC_CHECK_VARS} ${MKC_REQUIRE_VARS}
.if !defined(HAVE_VAR.${d:S/./_/g:S/:/./g:S|/|_|g})
HAVE_VAR.${d:S/./_/g:S/:/./g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_decl variable ${d:S/:/ /g}
.endif
.if ${HAVE_VAR.${d:S/./_/g:S/:/./g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_VAR_${d:tu:S/:/_/g:S/./_/g:S|/|_|g}=1
.endif
.endfor

.for d in ${MKC_REQUIRE_VARS}
.if !${HAVE_VAR.${d:S/./_/g:S/:/./g:S|/|_|g}}
MKC_ERR_MSG+=		"ERROR: cannot find declaration of variable ${d}"
.endif
.endfor

# checking for struct members
.for m in ${MKC_CHECK_MEMBERS} ${MKC_REQUIRE_MEMBERS}
.if !defined(HAVE_MEMBER.${m:S/./_/g:S/:/./g:S|/|_|g:S/-/_/g})
HAVE_MEMBER.${m:S/./_/g:S/:/./g:S|/|_|g:S/-/_/g}   !=   env ${mkc.environ} mkc_check_decl member ${m:S/:/ /g}
.endif
.if ${HAVE_MEMBER.${m:S/./_/g:S/:/./g:S|/|_|g:S/-/_/g}}
MKC_CFLAGS  +=  -DHAVE_MEMBER_${m:tu:S/:/_/g:S/./_/g:S|/|_|g:S/-/_/g}=1
.endif
.endfor

.for m in ${MKC_REQUIRE_MEMBERS}
.if !${HAVE_MEMBER.${m:S/./_/g:S/:/./g:S|/|_|g:S/-/_/g}}
MKC_ERR_MSG+=		"ERROR: cannot find member ${m}"
.endif
.endfor

# checking for declared functions
.for n in 0 1 2 3 4 5 6 7 8 9

.for d in ${MKC_CHECK_FUNCS${n}} ${MKC_REQUIRE_FUNCS${n}}
.if !defined(HAVE_FUNC${n}.${d:S/./_/g:S/:/./g:S|/|_|g})
HAVE_FUNC${n}.${d:S/./_/g:S/:/./g:S|/|_|g}   !=   env ${mkc.environ} mkc_check_decl func${n} ${d:S/:/ /g}
.endif
.if ${HAVE_FUNC${n}.${d:S/./_/g:S/:/./g:S|/|_|g}}
MKC_CFLAGS  +=  -DHAVE_FUNC${n}_${d:tu:S/:/_/g:S/./_/g:S|/|_|g}=1
.endif
.endfor # d

.for d in ${MKC_REQUIRE_FUNCS${n}}
.if !${HAVE_FUNC${n}.${d:S/./_/g:S/:/./g:S|/|_|g}}
MKC_ERR_MSG+=		"ERROR: cannot find declaration of function ${d}"
.endif
.endfor # d

.endfor # n

# custom checks
.for c in ${MKC_CHECK_CUSTOM} ${MKC_REQUIRE_CUSTOM}
.if !defined(HAVE_CUSTOM.${c})
.if !defined(MKC_CUSTOM_FN.${c})
MKC_CUSTOM_FN.${c}=${c}.c
.endif
HAVE_CUSTOM.${c}   !=   env ${mkc.environ} mkc_check_custom ${MKC_CUSTOM_DIR}/${MKC_CUSTOM_FN.${c}}
.endif
.if ${HAVE_CUSTOM.${c}}
MKC_CFLAGS  +=  -DHAVE_CUSTOM_${c:tu}=${HAVE_CUSTOM.${c}}
.endif
.endfor

.for c in ${MKC_REQUIRE_CUSTOM}
.if !${HAVE_CUSTOM.${c}}
MKC_ERR_MSG+=		"ERROR: custom test ${c} failed"
.endif
.endfor

# checking for declared #define
.for p in ${MKC_CHECK_PROGS} ${MKC_REQUIRE_PROGS}
.if !defined(PROG.${p})
PROG.${p}   !=   	env ${mkc.environ} mkc_check_prog '${p}'
.endif # !defined(PROG.${p})
.if !empty(PROG.${p})
HAVE_PROG.${p}=		1
.else
HAVE_PROG.${p}=		0
.endif
.endfor # p

.for p in ${MKC_REQUIRE_PROGS}
.if !${HAVE_PROG.${p}}
MKC_ERR_MSG+=		"ERROR: cannot find program ${p}"
.endif
.endfor # p

# final assignment
.if !${MKC_NOAUTO:U0}
CFLAGS += ${MKC_CFLAGS}
LDADD  += ${MKC_LDADD}
SRCS   += ${MKC_SRCS}
.endif

.endif # !make(clean) && !make(cleandir) && !make(distclean)
